<html><head><META http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>More about Tasks - Gradle User Guide Version 2.14.1</title><link xmlns:xslthl="http://xslthl.sf.net" type="text/css" rel="stylesheet" href="base.css"><link xmlns:xslthl="http://xslthl.sf.net" type="text/css" rel="stylesheet" href="docs.css"><link xmlns:xslthl="http://xslthl.sf.net" type="text/css" rel="stylesheet" href="userguide.css"><meta content="DocBook XSL Stylesheets V1.75.2" name="generator"><link rel="home" href="userguide.html" title="Gradle User Guide Version 2.14.1"><link rel="up" href="pt03.html" title="Part&nbsp;III.&nbsp;Writing Gradle build scripts"><link rel="prev" href="writing_build_scripts.html" title="Writing Build Scripts - Gradle User Guide Version 2.14.1"><link rel="next" href="working_with_files.html" title="Working With Files - Gradle User Guide Version 2.14.1"></head><body><div class="navheader"><div><div class="navbar"><a xmlns:xslthl="http://xslthl.sf.net" href="writing_build_scripts.html" title="Writing Build Scripts - Gradle User Guide Version 2.14.1">Previous</a><span>|</span><a xmlns:xslthl="http://xslthl.sf.net" href="userguide.html" title="Gradle User Guide Version 2.14.1">Contents</a><span>|</span><a xmlns:xslthl="http://xslthl.sf.net" href="working_with_files.html" title="Working With Files - Gradle User Guide Version 2.14.1">Next</a></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 xmlns:xslthl="http://xslthl.sf.net"><a name="more_about_tasks"></a>Chapter&nbsp;17.&nbsp;More about Tasks</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="more_about_tasks.html#N1110C">17.1. Defining tasks</a></span></dt><dt><span class="section"><a href="more_about_tasks.html#N11143">17.2. Locating tasks</a></span></dt><dt><span class="section"><a href="more_about_tasks.html#sec:configuring_tasks">17.3. Configuring tasks</a></span></dt><dt><span class="section"><a href="more_about_tasks.html#sec:adding_dependencies_to_tasks">17.4. Adding dependencies to a task</a></span></dt><dt><span class="section"><a href="more_about_tasks.html#sec:ordering_tasks">17.5. Ordering tasks</a></span></dt><dt><span class="section"><a href="more_about_tasks.html#N112F7">17.6. Adding a description to a task</a></span></dt><dt><span class="section"><a href="more_about_tasks.html#N11309">17.7. Replacing tasks</a></span></dt><dt><span class="section"><a href="more_about_tasks.html#N11326">17.8. Skipping tasks</a></span></dt><dt><span class="section"><a href="more_about_tasks.html#sec:up_to_date_checks">17.9. Skipping tasks that are up-to-date</a></span></dt><dt><span class="section"><a href="more_about_tasks.html#N113FA">17.10. Task rules</a></span></dt><dt><span class="section"><a href="more_about_tasks.html#N11431">17.11. Finalizer tasks</a></span></dt><dt><span class="section"><a href="more_about_tasks.html#sec:the_idea_behind_gradle_tasks">17.12. Summary</a></span></dt></dl></div><p>In the introductory tutorial (<a class="xref" href="tutorial_using_tasks.html">Chapter&nbsp;14, <i>Build Script Basics</i></a>) you learned how to
        create simple tasks. You also learned how to add additional behavior to these tasks later on, and you 
        learned how to create dependencies between tasks. This was all about simple tasks, but Gradle takes the concept
        of tasks further. Gradle supports <em class="firstterm">enhanced tasks</em>, which are tasks that have their own
        properties and methods. This is really different from what you are used to with Ant targets. Such enhanced tasks are
        either provided by you or built into Gradle.
    </p><p>在介绍教程（第14章 构建脚本基础）中，你已经了解了如何创建简单的任务，随后也知道如何为任务添加额外的行为（即任务的action），并且你也明白怎么设置任务之间的依赖。这些都是关于简单任务的，但Gradle进一步深化了任务的概念。Gradle支持增强型任务，它有自己的属性和方法。这与你曾经用过的Ant目标是完全不同的。这样的增强型任务要么是自定义的，要么是Gradle内置的。</p>
	<div class="section"><div class="titlepage"><div><div><h2 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="N1110C" class="section-anchor" href="#N1110C"></a>17.1.&nbsp;Defining tasks</h2></div></div></div><p>We have already seen how to define tasks using a keyword style in <a class="xref" href="tutorial_using_tasks.html">Chapter&nbsp;14, <i>Build Script Basics</i></a>.
            There are a few variations on this style, which you may need to use in certain situations. For example,
            the keyword style does not work in expressions.
        </p><p>在“第14章 构建脚本基础”中，你已经见过如何使用关键字形式来定义任务。这里与之前的有些不同（学习使用一种新的方式），在某些场景下得使用这种形式。例如，关键字形式在表达式中不起作用。</p>
		<div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="defineAsExpression"></a><p class="title"><b>Example&nbsp;17.1.&nbsp;Defining tasks</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task(hello) &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"hello"</span>
}

task(copy, type: Copy) {
    from(file(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'srcDir'</span>))
    into(buildDir)
}
</pre></div></div><br class="example-break"><p>You can also use strings for the task names:</p><p>你也可以使用字符串作为任务名称。</p>
<div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="defineUsingStringTaskNames"></a><p class="title"><b>Example&nbsp;17.2.&nbsp;Defining tasks - using strings for task names</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'hello'</span>) &lt;&lt;
{
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"hello"</span>
}

task(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'copy'</span>, type: Copy) {
    from(file(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'srcDir'</span>))
    into(buildDir)
}
</pre></div></div><br class="example-break"><p>There is an alternative syntax for defining tasks, which you may prefer to use:</p><p>还有一种定义任务的替代语法，你可能会比较喜欢使用。</p>
<div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="addToTaskContainer"></a><p class="title"><b>Example&nbsp;17.3.&nbsp;Defining tasks with alternative syntax</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">tasks.create(name: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'hello'</span>) &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"hello"</span>
}

tasks.create(name: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'copy'</span>, type: Copy) {
    from(file(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'srcDir'</span>))
    into(buildDir)
}
</pre></div></div><br class="example-break"><p>Here we add tasks to the <code class="literal">tasks</code> collection. Have a look at
            <a class="ulink" href="../javadoc/org/gradle/api/tasks/TaskContainer.html" target="_top"><code class="classname">TaskContainer</code></a> for more variations of the <code class="literal">create()</code>
            method.</p><p>这里，我们为任务集合添加了任务。可以查看TaskContainer了解更多create()方法的变化形式（即重载方法，参数个数、类型、顺序不同）。</p>
			</div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="N11143" class="section-anchor" href="#N11143"></a>17.2.&nbsp;Locating tasks</h2></div></div></div><p>You often need to locate the tasks that you have defined in the build file, for example, to configure them
            or use them for dependencies. There are a number of ways of doing this. Firstly, each task is available as
            a property of the project, using the task name as the property name:
        </p><p>你经常需要检索（或引用）在构建文件中定义的任务，比如，修改任务或者设置依赖时。有许多方法可以方便引用，最简单的方法是使用任务名作为属性名，因为对项目来说每一个任务都是可用的属性。</p>
		<div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="accessAsProperty"></a><p class="title"><b>Example&nbsp;17.4.&nbsp;Accessing tasks as properties</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task hello

println hello.name
println project.hello.name
</pre></div></div><br class="example-break"><p>Tasks are also available through the <code class="literal">tasks</code> collection.</p><p>在任务集合（任务数组）中引用任务也是有效的。</p>
<div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="accessFromTaskContainer"></a><p class="title"><b>Example&nbsp;17.5.&nbsp;Accessing tasks via tasks collection</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task hello

println tasks.hello.name
println tasks[<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'hello'</span>].name
</pre></div></div><br class="example-break"><p>You can access tasks from any project using the task's path using the <code class="literal">tasks.getByPath()</code>
            method. You can call the <code class="literal">getByPath()</code> method with a task name, or a relative path, or an
            absolute path.</p><p><font color='red'>在任何项目中，你都可以在tasks.getByPath()方法中使用任务的路径来访问任务。</font>getByPath()方法参数可为任务名、相对路径、绝对路径。</p>
			<div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="accessUsingPath"></a><p class="title"><b>Example&nbsp;17.6.&nbsp;Accessing tasks by path</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">project(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">':projectA'</span>) {
    task hello
}

task hello

println tasks.getByPath(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'hello'</span>).path
println tasks.getByPath(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">':hello'</span>).path
println tasks.getByPath(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'projectA:hello'</span>).path
println tasks.getByPath(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">':projectA:hello'</span>).path
</pre><p>Output of <strong class="userinput"><code>gradle -q hello</code></strong></p><pre class="screen">&gt; gradle -q hello
:hello
:hello
:projectA:hello
:projectA:hello</pre></div></div><br class="example-break"><p>Have a look at <a class="ulink" href="../javadoc/org/gradle/api/tasks/TaskContainer.html" target="_top"><code class="classname">TaskContainer</code></a> for more options for locating tasks.</p><p>查看TaskContainer了解更多定位任务的详情。</p>
</div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:configuring_tasks" class="section-anchor" href="#sec:configuring_tasks"></a>17.3.&nbsp;Configuring tasks</h2></div></div></div><p>As an example, let's look at the <code class="classname">Copy</code> task provided by Gradle. To create a
            <code class="classname">Copy</code> task for your build, you can declare in your build script:
        </p><p>如示例所示，看看Gradle提供的Copy任务。在你的构建脚本中这样声明，可以创建一个Copy任务：</p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="declareTask"></a><p class="title"><b>Example&nbsp;17.7.&nbsp;Creating a copy task</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task myCopy(type: Copy)
</pre></div></div><br class="example-break"><p>This creates a copy task with no default behavior.
            The task can be configured using its API (see <a class="ulink" href="../dsl/org.gradle.api.tasks.Copy.html" target="_top"><code class="classname">Copy</code></a>).
			The following examples show several different ways to achieve the same configuration.
        </p><p>它创建一个copy任务，但是没有默认行为，可以使用其API来配置（行为）。下面的示例演示了通过几种不同的方法来实现相同的设置。</p><p>Just to be clear, realize that the name of this task is &ldquo;<code class="literal">myCopy</code>&rdquo;, but it is of
        <span class="emphasis"><em>type</em></span> &ldquo;<code class="literal">Copy</code>&rdquo;.  You can have multiple tasks of the same
        <span class="emphasis"><em>type</em></span>, but with different names. You'll find this gives you a lot of power to implement
        cross-cutting concerns across all tasks of a particular type.
        </p><p>要清楚地意识到，这个任务的名称是myCopy，但是它是Copy类型的。你可以定义多个同一类型的任务，但名称不能相同。<font color='red'>你会发现，它可以帮助你实现针对某种类型的所有任务的切面配置（你所关注的点）。</font></p>
		<div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="configureUsingVar"></a><p class="title"><b>Example&nbsp;17.8.&nbsp;Configuring a task - various ways（配置任务-广义上的方法，即通用的方法）</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">Copy myCopy = task(myCopy, type: Copy)
myCopy.from <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'resources'</span>
myCopy.into <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'target'</span>
myCopy.include(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'**/*.txt'</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'**/*.xml'</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'**/*.properties'</span>)
</pre></div></div><br class="example-break"><p>This is similar to the way we would configure objects in Java. You have to repeat the context
            (<code class="literal">myCopy</code>) in the configuration statement every time. This is a redundancy and not very
            nice to read.
        </p><p>这是与Java中定义对象的方法类似，你得在每条设置语句中重复写对象实例（myCopy），这其实是多余的并且代码可读性也不好。</p><p>There is another way of configuring a task. It also preserves the context and it is arguably the
            most readable. It is usually our favorite.
        </p><p>有另一种配置任务的方法。它也会持有对象实例，并且也是公认的可读性最好的方式。它通常人们最喜欢的方式。</p>
		<div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="configureUsingClosure"></a><p class="title"><b>Example&nbsp;17.9.&nbsp;Configuring a task - with closure（使用闭包结构）</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task myCopy(type: Copy)

myCopy {
   from <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'resources'</span>
   into <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'target'</span>
   include(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'**/*.txt'</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'**/*.xml'</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'**/*.properties'</span>)
}
</pre></div></div><br class="example-break"><p>This works for <span class="emphasis"><em>any</em></span> task. Line 3 of the example is just a shortcut for the
            <code class="literal">tasks.getByName()</code> method. It is important to note that if you pass a closure to the
            <code class="literal">getByName()</code> method, this closure is applied to <span class="emphasis"><em>configure</em></span> the task, not when
            the task executes.
        </p><p>You can also use a configuration closure when you define a task.</p><p>这在任何任务中都是合法有效的。例子的第三行myCopy是tasks.getByName()的快捷方式。<font color='red'>切记，如果你传递一个闭包给getByName()方法，则会在配置阶段（configuration phase）应用闭包，而不是在任务执行时。</font><br><br>你也可以使用一个configureClosure来定义任务。</p>
		<p>构建周期有三个不同的阶段：初始化阶段（Initialization，创建项目对象）、配置阶段（Configuration，配置项目对象）、执行阶段（Execution，执行任务集）</p>
		<p>任务具有配置与操作（或者称为行为，等同于类的属性与方法）。当使用<code class="literal">&lt;&lt;</code>时，你仅仅用简洁的方式来定义一个操作。在任务配置部分定义的代码会在构建的配置阶段（configuration phase）执行，不管任务是做什么用的。</p>
		<div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="defineAndConfigure"></a><p class="title"><b>Example&nbsp;17.10.&nbsp;Defining a task with closure（使用闭包定义任务）</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task copy(type: Copy) {
   from <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'resources'</span>
   into <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'target'</span>
   include(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'**/*.txt'</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'**/*.xml'</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'**/*.properties'</span>)
}
</pre></div></div><br class="example-break"><div class="tip"><h3 class="title">Don't forget about the build phases</h3><p>A task has both configuration and actions.
                When using the <code class="literal">&lt;&lt;</code>, you are simply using a shortcut to define an action.
                Code defined in the configuration section of your task will get executed during the configuration phase of the build regardless of what task was targeted.
                See <a class="xref" href="build_lifecycle.html">Chapter&nbsp;20, <i>The Build Lifecycle</i></a> for more details about the build lifecycle.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:adding_dependencies_to_tasks" class="section-anchor" href="#sec:adding_dependencies_to_tasks"></a>17.4.&nbsp;Adding dependencies to a task</h2></div></div></div><p>There are several ways you can define the dependencies of a task. In
            <a class="xref" href="tutorial_using_tasks.html#sec:task_dependencies">Section&nbsp;14.5, &ldquo;Task dependencies&rdquo;</a>
            you were introduced to defining dependencies using task names. Task names can refer to tasks in the same
            project as the task, or to tasks in other projects. To refer to a task in another project, you prefix the
            name of the task with the path of the project it belongs to. The following is an example which adds a dependency
            from
            <code class="literal">projectA:taskX</code>
            to
            <code class="literal">projectB:taskY</code>:
        </p><p>有几种方法来为任务定义依赖。在“14.5节，任务依赖”中，已经向你介绍过使用任务名称来定义依赖。可以通过任务名称来引用任务，不管是在本项目，还是其他项目。为了在其他项目中引用，你要在任务前面加上它所属的项目作为前辍。下面是一个例子，它演示了给项目A的taskX任务添加依赖，依赖的任务是项目B中的taskY。</p>
		<div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="addDependencyUsingPath"></a><p class="title"><b>Example&nbsp;17.11.&nbsp;Adding dependency on task from another project</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">project(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'projectA'</span>) {
    task taskX(dependsOn: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">':projectB:taskY'</span>) &lt;&lt; {
        println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'taskX'</span>
    }
}

project(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'projectB'</span>) {
    task taskY &lt;&lt; {
        println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'taskY'</span>
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q taskX</code></strong></p><pre class="screen">&gt; gradle -q taskX
taskY
taskX
</pre></div></div><br class="example-break"><p>Instead of using a task name, you can define a dependency using a
            <code class="classname">Task</code> object, as shown in this example:
        </p><p>也可以使用任务对象代替任务名称来定义依赖，示例如下：</p>
		<div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="addDependencyUsingTask"></a><p class="title"><b>Example&nbsp;17.12.&nbsp;Adding dependency using task object</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task taskX &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'taskX'</span>
}

task taskY &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'taskY'</span>
}

taskX.dependsOn taskY
</pre><p>Output of <strong class="userinput"><code>gradle -q taskX</code></strong></p><pre class="screen">&gt; gradle -q taskX
taskY
taskX
</pre></div></div><br class="example-break"><p>For more advanced uses, you can define a task dependency using a closure. When evaluated, the closure is
            passed the task whose dependencies are being calculated. The closure should return a single
            <code class="classname">Task</code> or collection of <code class="classname">Task</code> objects, which are then treated
            as dependencies of the task. The following example adds a dependency from <code class="literal">taskX</code>
            to all the tasks in the project whose name starts with <code class="literal">lib</code>:
        </p><p>在高级的用法中，可以使用闭包来定义任务依赖。评估时计算出任务依赖，并将闭包并传递给任务。闭包返回单个任务或者任务对象集，以此作为任务的依赖。下面的例子演示了给taskX添加依赖，依赖任务的名称以lib开头。</p>
		<div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="addDependencyUsingClosure"></a><p class="title"><b>Example&nbsp;17.13.&nbsp;Adding dependency using closure</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task taskX &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'taskX'</span>
}

taskX.dependsOn {
    tasks.findAll { task -&gt; task.name.startsWith(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'lib'</span>) }
}

task lib1 &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'lib1'</span>
}

task lib2 &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'lib2'</span>
}

task notALib &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'notALib'</span>
}
</pre><p>Output of <strong class="userinput"><code>gradle -q taskX</code></strong></p><pre class="screen">&gt; gradle -q taskX
lib1
lib2
taskX
</pre></div></div><br class="example-break"><p>For more information about task dependencies, see the <a class="ulink" href="../dsl/org.gradle.api.Task.html" target="_top"><code class="classname">Task</code></a> API.</p><p>查看Task API，可获得更多关于任务依赖的内容。</p>
</div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:ordering_tasks" class="section-anchor" href="#sec:ordering_tasks"></a>17.5.&nbsp;Ordering tasks</h2></div></div></div><div class="note"><p>
                Task ordering is an <a class="link" href="feature_lifecycle.html">incubating</a> feature. Please be aware that this feature may change in later Gradle versions.
            </p><p>任务执行顺序是孵化中的功能。请记住，在后面的版本中可能会演变。</p></div><p>
            In some cases it is useful to control the <span class="emphasis"><em>order</em></span> in which 2 tasks will execute, without introducing an explicit dependency between those tasks.
            The primary difference between a task <span class="emphasis"><em>ordering</em></span> and a task <span class="emphasis"><em>dependency</em></span> is that an ordering rule does not influence which tasks
            will be executed, only the order in which they will be executed.
        </p><p>Task ordering can be useful in a number of scenarios:</p><p>在某些情况下，即便不需要显式声明任务的依赖，也能控制2个任务的执行顺序，这会非常有用。任务顺序与任务依赖最大的不同，就是顺序规则不会影响任务的执行，只决定他们执行的顺序。（任务依赖不一样，依赖可能会有状态改变、数据传递等，会影响任务的执行）<br><br>控制顺序在许多场景下会很有用：</p>
		<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Enforce sequential ordering of tasks: eg. 'build' never runs before 'clean'.</li><li class="listitem">Run build validations early in the build: eg. validate I have the correct credentials before starting the work for a release build.</li><li class="listitem">Get feedback faster by running quick verification tasks before long verification tasks: eg. unit tests should run before integration tests.</li><li class="listitem">A task that aggregates the results of all tasks of a particular type: eg. test report task combines the outputs of all executed test tasks.</li></ul></div><p>强制任务执行的顺序。例如，“构建”永远不会在“清理”之前执行。<br>在构建早期进行构建验证。例如，在开始发版之前，验证证书是否合法。<br>在执行耗时长的验证任务之前先执行耗时少的任务，以便更快地得到反馈。例如：单元测试应在集成测试之前运行。<br>汇总某种类型的所有任务的结果信息。例如，report任务统计了所有的测试任务的输出。</p><p>
            There are two ordering rules available: &ldquo;<span class="emphasis"><em>must run after</em></span>&rdquo; and &ldquo;<span class="emphasis"><em>should run after</em></span>&rdquo;.
        </p><p>有两种排序规则：“必须在……之后”和“应该在……之后”</p><p>When you use the &ldquo;must run after&rdquo; ordering rule you specify that <code class="literal">taskB</code> must always
        run after <code class="literal">taskA</code>, whenever both <code class="literal">taskA</code> and <code class="literal">taskB</code> will
        be run. This is expressed as <code class="literal">taskB.mustRunAfter(taskA)</code>. The &ldquo;should run
        after&rdquo; ordering rule is similar but less strict as it will be ignored in two situations. Firstly if using
        that rule introduces an ordering cycle. Secondly when using parallel execution and all dependencies of a
        task have been satisfied apart from the &ldquo;should run after&rdquo; task, then this task will be run regardless of
        whether its &ldquo;should run after&rdquo; dependencies have been run or not. You should use &ldquo;should run after&rdquo;
        where the ordering is helpful but not strictly required.
        </p><p>当你使用“必须在……之后运行”规则后，指定taskB必须在taskA之后执行，不管taskA与taskB什么时候执行，可表示为taskB.mustRunAfter(taskA)。“应该在……之后运行”规则与之类似但不是那么严格，在两种情况下会被忽略。首先，如果使用这个规则会引入循环执行。其次，当使用了并行构建，任务的依赖都满足了除了“应该在……之后运行”的任务，此时，任务会直接运行，不管它的“应该在……之后运行”的依赖是否运行。在顺序执行对构建有助但又没有严格时，你应该使用“应该在……之后运行”规则。</p>
		<p>With these rules present it is still possible to execute <code class="literal">taskA</code> without <code class="literal">taskB</code> and vice-versa.
        </p><p>按照下面的顺序规则，即使没有任务B，任务A也能执行，反之亦然。</p>
		<div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="mustRunAfter"></a><p class="title"><b>Example&nbsp;17.14.&nbsp;Adding a 'must run after' task ordering</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task taskX &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'taskX'</span>
}
task taskY &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'taskY'</span>
}
taskY.mustRunAfter taskX
</pre><p>Output of <strong class="userinput"><code>gradle -q taskY taskX</code></strong></p><pre class="screen">&gt; gradle -q taskY taskX
taskX
taskY</pre></div></div><br class="example-break"><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="shouldRunAfter"></a><p class="title"><b>Example&nbsp;17.15.&nbsp;Adding a 'should run after' task ordering</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task taskX &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'taskX'</span>
}
task taskY &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'taskY'</span>
}
taskY.shouldRunAfter taskX
</pre><p>Output of <strong class="userinput"><code>gradle -q taskY taskX</code></strong></p><pre class="screen">&gt; gradle -q taskY taskX
taskX
taskY</pre></div></div><br class="example-break"><p>In the examples above, it is still possible to execute <code class="literal">taskY</code> without causing <code class="literal">taskX</code> to run:</p><p>在上面的例子中，即使没有触发taskX执行，taskY也能够执行。</p>
<div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="mustRunAfterSingleTask"></a><p class="title"><b>Example&nbsp;17.16.&nbsp;Task ordering does not imply task execution</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>gradle -q taskY</code></strong></p><pre class="screen">&gt; gradle -q taskY
taskY</pre></div></div><br class="example-break"><p>To specify a &ldquo;must run after&rdquo; or &ldquo;should run after&rdquo; ordering between 2 tasks, you use the <a class="ulink" href="../dsl/org.gradle.api.Task.html#org.gradle.api.Task:mustRunAfter(java.lang.Object[])" target="_top"><code class="classname">Task.mustRunAfter(java.lang.Object[])</code></a> and <a class="ulink" href="../javadoc/org/gradle/api/Task.html#shouldRunAfter(java.lang.Object[])" target="_top"><code class="classname">Task.shouldRunAfter(java.lang.Object[])</code></a> methods.
            These methods accept a task instance, a task name or any other input accepted by <a class="ulink" href="../dsl/org.gradle.api.Task.html#org.gradle.api.Task:dependsOn(java.lang.Object[])" target="_top"><code class="classname">Task.dependsOn(java.lang.Object[])</code></a>.
        </p><p>为了给2个任务指定“必须在……之后”或者“应该在……之后”顺序，你应该使用Task.mustRunAfter或者Task.shouldRunAfter方法。这些方法接受一个任务实例参数，或者是任务名，或者Task.dependsOn()方法可接受的任意输入。</p><p>
            Note that &ldquo;<code class="literal">B.mustRunAfter(A)</code>&rdquo; or &ldquo;<code class="literal">B.shouldRunAfter(A)</code>&rdquo; does not imply any execution dependency between the tasks:
        </p><p>注意，“B.mustRunAfter(A)”或者“B.shouldRunAfter(A)”不隐含任务间的任何依赖（即不包括任务间的依赖）。</p>
		<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">It is possible to execute tasks <code class="literal">A</code> and <code class="literal">B</code> independently. The ordering rule only has an effect when both tasks are scheduled for execution.</li><li class="listitem">When run with <code class="literal">--continue</code>, it is possible for <code class="literal">B</code> to execute in the event that <code class="literal">A</code> fails.</li></ul></div><p>可以单独执行taskA和taskB。顺序规则只在任务被列为一起执行时起作用。<br>当使用--continue开启时，可以在A失败时继续执行B。</p>
		<p>As mentioned before, the &ldquo;should run after&rdquo; ordering rule will be ignored if it introduces an ordering cycle:</p><p>如前所述，“应该在……之后”顺序规则在引入循环时会被忽略。</p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="shouldRunAfterWithCycle"></a><p class="title"><b>Example&nbsp;17.17.&nbsp;A 'should run after' task ordering is ignored if it introduces an ordering cycle</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task taskX &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'taskX'</span>
}
task taskY &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'taskY'</span>
}
task taskZ &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'taskZ'</span>
}
taskX.dependsOn taskY
taskY.dependsOn taskZ
taskZ.shouldRunAfter taskX
</pre><p>Output of <strong class="userinput"><code>gradle -q taskX</code></strong></p><pre class="screen">&gt; gradle -q taskX
taskZ
taskY
taskX</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="N112F7" class="section-anchor" href="#N112F7"></a>17.6.&nbsp;Adding a description to a task</h2></div></div></div><p>You can add a description to your task. This description is displayed when executing
            <strong class="userinput"><code>gradle tasks</code></strong>.
        </p><p>你可以为任务添加描述，描述会在“gradle tasks”命令执行时显示。</p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="describeTask"></a><p class="title"><b>Example&nbsp;17.18.&nbsp;Adding a description to a task</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task copy(type: Copy) {
   description <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'Copies the resource directory to the target directory.'</span>
   from <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'resources'</span>
   into <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'target'</span>
   include(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'**/*.txt'</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'**/*.xml'</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'**/*.properties'</span>)
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="N11309" class="section-anchor" href="#N11309"></a>17.7.&nbsp;Replacing tasks</h2></div></div></div><p>Sometimes you want to replace a task. For example, if you want to exchange a task added by the Java plugin
            with a custom task of a different type. You can achieve this with:
        </p><p>有时间你可能想替换一个任务，比如你想用自定义的其他类型的任务替换java插件的任务。你可以这么做：</p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="replaceTask"></a><p class="title"><b>Example&nbsp;17.19.&nbsp;Overwriting a task</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task copy(type: Copy)

task copy(overwrite: true) &lt;&lt; {
    println(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'I am the new one.'</span>)
}
</pre><p>Output of <strong class="userinput"><code>gradle -q copy</code></strong></p><pre class="screen">&gt; gradle -q copy
I am the new one.
</pre></div></div><br class="example-break"><p>This will replace a task of type <code class="literal">Copy</code> with the task you've defined, because it
        uses the same name. When you define the new task, you have to set the <code class="literal">overwrite</code> property
        to true. Otherwise Gradle throws an exception, saying that a task with that name already exists.
        </p><p>这会用你定义的任务来替换Copy类型的任务，因为它们名称相同。当定义一个新的任务时，你必须设置overwrite属性为true。否则Gradle会抛出异常，告诉你此名称的任务已经存在。</p>
		</div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="N11326" class="section-anchor" href="#N11326"></a>17.8.&nbsp;Skipping tasks</h2></div></div></div><p>Gradle offers multiple ways to skip the execution of a task.</p><p>Gradle提供了许多方法来跳过某个任务的执行。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="N1132B" class="section-anchor" href="#N1132B"></a>17.8.1.&nbsp;Using a predicate（使用断言）</h3></div></div></div><p>You can use the <code class="literal">onlyIf()</code> method to attach a predicate to a task. The task's
                actions are only executed if the predicate evaluates to true. You implement the predicate as a closure.
                The closure is passed the task as a parameter, and should return true if the task should execute
                and false if the task should be skipped. The predicate is evaluated just before the task is due
                to be executed.
                </p><p>你可以使用onlyIf()来为任务附加一个断言。任务的只会在断言评估出真值时才会执行。可用闭包的形式来实现断言。闭包作为一个参数传递给任务，如果闭包返回为真，则任务为执行；如果返回为假，则任务被跳过。断言只在任务执行前被评估。</p>
				<div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="taskOnlyIf"></a><p class="title"><b>Example&nbsp;17.20.&nbsp;Skipping a task using a predicate</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task hello &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'hello world'</span>
}

hello.onlyIf { !project.hasProperty(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'skipHello'</span>) }
</pre><p>Output of <strong class="userinput"><code>gradle hello -PskipHello</code></strong></p><pre class="screen">&gt; gradle hello -PskipHello
:hello SKIPPED

BUILD SUCCESSFUL

Total time: 1 secs
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="N11343" class="section-anchor" href="#N11343"></a>17.8.2.&nbsp;Using StopExecutionException</h3></div></div></div><p>If the logic for skipping a task can't be expressed with a predicate, you can use the
            <a class="ulink" href="../javadoc/org/gradle/api/tasks/StopExecutionException.html" target="_top"><code class="classname">StopExecutionException</code></a>. If this exception is thrown by an action,
            the further execution of this action as well as the execution of any following action of this task is skipped. The build continues with executing the next task.
        </p><p>如果跳过任务的逻辑不能用断言表示出来，那你可以使用StopExecutionException。如果在执行action时抛出这个异常，那将跳过此操作的进一步执行，以及该任务任何后续的操作的执行。构建继续执行下一个任务。</p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="stopExecutionException"></a><p class="title"><b>Example&nbsp;17.21.&nbsp;Skipping tasks with StopExecutionException</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task compile &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'We are doing the compile.'</span>
}

compile.doFirst {
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// Here you would put arbitrary conditions in real life.</span>
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// But this is used in an integration test so we want defined behavior.</span>
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (true) { <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">throw</span> <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">new</span> StopExecutionException() }
}
task myTask(dependsOn: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'compile'</span>) &lt;&lt; {
   println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'I am not affected'</span>
}
</pre><p>Output of <strong class="userinput"><code>gradle -q myTask</code></strong></p><pre class="screen">&gt; gradle -q myTask
I am not affected
</pre></div></div><br class="example-break"><p>This feature is helpful if you work with tasks provided by Gradle. It allows you to add
            <span class="emphasis"><em>conditional</em></span> execution of the built-in actions of such a task.
            <sup>[<a href="#ftn.N11362" name="N11362" class="footnote">7</a>]</sup>
        </p><p>此功能在你想对Gradle内置的任务做些控制时非常有用。它允许你给任务内置的action添加条件逻辑，以便更好地按你的需要行事。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="N1136C" class="section-anchor" href="#N1136C"></a>17.8.3.&nbsp;Enabling and disabling tasks</h3></div></div></div><p>Every task has an <code class="literal">enabled</code>
            flag which defaults to <code class="literal">true</code>. Setting it to <code class="literal">false</code> prevents the
            execution of any of the task's actions.
        </p><p>每个任务都有启用标志，默认为true。如果设置为fals，则可以阻止任何任务的操作执行。</p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="disableTask"></a><p class="title"><b>Example&nbsp;17.22.&nbsp;Enabling and disabling tasks</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task disableMe &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'This should not be printed if the task is disabled.'</span>
}
disableMe.enabled = false
</pre><p>Output of <strong class="userinput"><code>gradle disableMe</code></strong></p><pre class="screen">&gt; gradle disableMe
:disableMe SKIPPED

BUILD SUCCESSFUL

Total time: 1 secs
</pre></div></div><br class="example-break"></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:up_to_date_checks" class="section-anchor" href="#sec:up_to_date_checks"></a>17.9.&nbsp;Skipping tasks that are up-to-date</h2></div></div></div><p>If you are using one of the tasks that come with Gradle, such as a task added by the Java plugin,
            you might have noticed that Gradle will skip tasks that are up-to-date. This behaviour is also available
            for your tasks, not just for built-in tasks.
        </p><p>如果你使用过Gradle提供的任务，比如由Java插件添加的任务，你可能注意到，Gradle跳过了那些提示“up-to-date”的任务。你也可以在你的任务中任务它，而不仅仅是内置任务。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:task_inputs_outputs" class="section-anchor" href="#sec:task_inputs_outputs"></a>17.9.1.&nbsp;Declaring a task's inputs and outputs</h3></div></div></div><p>
                Let's have a look at an example. Here our task generates several output files from a source XML file. Let's
                run it a couple of times.
            </p><p>让我们看看下面这个例子。在这，任务读取一个xml文件，然后生成了一些输出文件。让我们运行两次。</p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="generatorTask"></a><p class="title"><b>Example&nbsp;17.23.&nbsp;A generator task</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task transform {
    ext.srcFile = file(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'mountains.xml'</span>)
    ext.destDir = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">new</span> File(buildDir, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'generated'</span>)
    doLast {
        println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"Transforming source file."</span>
        destDir.mkdirs()
        def mountains = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">new</span> XmlParser().parse(srcFile)
        mountains.mountain.each { mountain -&gt;
            def name = mountain.name[<span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">0</span>].text()
            def height = mountain.height[<span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">0</span>].text()
            def destFile = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">new</span> File(destDir, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"${name}.txt"</span>)
            destFile.text = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"$name -&gt; ${height}\n"</span>
        }
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle transform</code></strong></p><pre class="screen">&gt; gradle transform
:transform
Transforming source file.</pre><p>Output of <strong class="userinput"><code>gradle transform</code></strong></p><pre class="screen">&gt; gradle transform
:transform
Transforming source file.</pre></div></div><br class="example-break"><p>Notice that Gradle executes this task a second time, and does not skip the task even though nothing has
                changed. Our example task was defined using an action closure. Gradle has no idea what the closure does and
                cannot automatically figure out whether the task is up-to-date or not. To use Gradle's up-to-date checking,
                you need to declare the inputs and outputs of the task.
            </p><p>Each task has an <code class="literal">inputs</code> and <code class="literal">outputs</code> property, which you use to
                declare the inputs and outputs of the task. Below, we have changed our example to declare that it takes
                the source XML file as an input and produces output to a destination directory. Let's run it a couple
                of times.
            </p><p>注意，Gradle在第二次执行这个任务时，没有跳过任务，尽管此时未输出新的东西。这个任务使用了闭包来定义操作。Gradle是不知道闭包做什么的，没办法自动标识出任务是否是最新的。要使用Gradle的“up-to-date”检测，你要在任务中定义输入与输出。<br><br>每个任务都有一个输入与输出属性，你可以使用它来声明任务的输入与输出。下面，我们修改这个例子，把xml源文件作为输入，把目标文件夹作为输出。我们再运行再次。</p>
			<div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="incrementalTask"></a><p class="title"><b>Example&nbsp;17.24.&nbsp;Declaring the inputs and outputs of a task</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task transform {
    ext.srcFile = file(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'mountains.xml'</span>)
    ext.destDir = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">new</span> File(buildDir, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'generated'</span>)
    inputs.file srcFile
    outputs.dir destDir
    doLast {
        println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"Transforming source file."</span>
        destDir.mkdirs()
        def mountains = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">new</span> XmlParser().parse(srcFile)
        mountains.mountain.each { mountain -&gt;
            def name = mountain.name[<span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">0</span>].text()
            def height = mountain.height[<span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">0</span>].text()
            def destFile = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">new</span> File(destDir, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"${name}.txt"</span>)
            destFile.text = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"$name -&gt; ${height}\n"</span>
        }
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle transform</code></strong></p><pre class="screen">&gt; gradle transform
:transform
Transforming source file.</pre><p>Output of <strong class="userinput"><code>gradle transform</code></strong></p><pre class="screen">&gt; gradle transform
:transform UP-TO-DATE
</pre></div></div><br class="example-break"><p>Now, Gradle knows which files to check to determine whether the task is up-to-date or not.</p><p>
                The task's <code class="literal">inputs</code> property is of type <a class="ulink" href="../javadoc/org/gradle/api/tasks/TaskInputs.html" target="_top"><code class="classname">TaskInputs</code></a>.
                The task's <code class="literal">outputs</code> property is of type <a class="ulink" href="../javadoc/org/gradle/api/tasks/TaskOutputs.html" target="_top"><code class="classname">TaskOutputs</code></a>.
            </p><p>
                A task with no defined outputs will <span class="emphasis"><em>never</em></span> be considered up-to-date.
                For scenarios where the outputs of a task are not files, or for more complex scenarios, the
                <a class="ulink" href="../javadoc/org/gradle/api/tasks/TaskOutputs.html#upToDateWhen(groovy.lang.Closure)" target="_top"><code class="classname">TaskOutputs.upToDateWhen(groovy.lang.Closure)</code></a> method allows you to calculate programmatically if
                the tasks outputs should be considered up to date.
            </p><p>
                A task with only outputs defined will be considered up-to-date if those outputs are unchanged since the previous build.
            </p><p>现在，Gradle知道检查哪些文件来判断任务是否是最新的。<br><br>任务的输入属性是TaskInputs类型，输出属性是TaskOutpus类型。<br><br>一个没有定义输出的文件是永远不会被认为是最新的。对于任务的输出不是文件，或者更复杂的场景。TaskOutputs.upToDateWhen()方法允许你以编程方式来计算任务输出是否应该被认为是最新的。<br><br>一个任务只有从上次构建输出后（输出）一直保持不变，才会被认为是最新的。</p>
			</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="N113EC" class="section-anchor" href="#N113EC"></a>17.9.2.&nbsp;How does it work?（它是怎么做到的）</h3></div></div></div><p>
                Before a task is executed for the first time, Gradle takes a snapshot of the inputs. This snapshot contains
                the set of input files and a hash of the contents of each file. Gradle then executes the task. If the
                task completes successfully, Gradle takes a snapshot of the outputs. This snapshot contains the set of
                output files and a hash of the contents of each file. Gradle persists both snapshots for the next time the task
                is executed.
            </p><p>在任务第一次执行前，Gradle对输入进行快照，快照包含输入文件集合以及每个文件的hash值。Gradle随后执行任务，如果任务成功执行完，它会对输出进行快照，快照包括输出文件集合以及每个文件的hash值。Gradle留存这两份快照用于下一次任务执行。</p><p>
                Each time after that, before the task is executed, Gradle takes a new snapshot of the inputs and outputs.
                If the new snapshots are the same as the previous snapshots, Gradle assumes that the outputs are up to
                date and skips the task. If they are not the same, Gradle executes the task. Gradle persists both snapshots
                for the next time the task is executed.
            </p><p>每次这样之后，在任务执行之前，Gradle会对输入与输出再次快照，跟上次的快照进行对比。如果新的快照与上次快照一样，Gradle认为输出是最新的并跳过任务。如果不同，Gradle就会执行任务，并留存输入与输出快照用于下次构建执行。</p><p>
                Note that if a task has an output directory specified, any files added to that directory since the last time it was executed
                are ignored and will NOT cause the task to be out of date. This is so unrelated tasks may share an output directory without interfering with each other.
                If this is not the behaviour you want for some reason, consider using <a class="ulink" href="../javadoc/org/gradle/api/tasks/TaskOutputs.html#upToDateWhen(groovy.lang.Closure)" target="_top"><code class="classname">TaskOutputs.upToDateWhen(groovy.lang.Closure)</code></a>
            </p><p>注意，如果任务指定了输出目录，自上次执行后，添加到此目录的任何文件会被忽略，不会导致任务过期。有些不相关的任务可能会共享一个输出目录但互相并不影响（互不干涉）。如果是出于某些考虑的需求，请考虑使用TaskOutputs.upToDateWhen()方法。</p>
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="N113FA" class="section-anchor" href="#N113FA"></a>17.10.&nbsp;Task rules</h2></div></div></div><p>Sometimes you want to have a task whose behavior depends on a large or infinite number value range
            of parameters. A very nice and expressive way to provide such tasks are task rules:
        </p><p>有时候，你希望有这样一个任务，它的行为取决于这样一个参数，参数在一个很大或者无穷大的数值区间内。一个方便又快捷的方法是为任务添加规则：</p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="taskRule"></a><p class="title"><b>Example&nbsp;17.25.&nbsp;Task rule</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">tasks.addRule(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"Pattern: ping&lt;ID&gt;"</span>) { String taskName -&gt;
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (taskName.startsWith(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"ping"</span>)) {
        task(taskName) &lt;&lt; {
            println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"Pinging: "</span> + (taskName - <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'ping'</span>)
        }
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q pingServer1</code></strong></p><pre class="screen">&gt; gradle -q pingServer1
Pinging: Server1
</pre></div></div><br class="example-break"><p>The String parameter is used as a description for the rule, which is shown with <strong class="userinput"><code>gradle tasks</code></strong>.
        </p><p>字符串参数用作规则的描述，当运行“gradle tasks”命令时会显示出来。（在输出信息的结尾Rules部分显示）</p><p>Rules are not only used when calling tasks from the command line. You can also create dependsOn relations
            on rule based tasks:
        </p><p>规则不仅仅是用在通过命令行调用任务时，也可以在任务的规则上创建依赖。</p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="taskRuleDependsOn"></a><p class="title"><b>Example&nbsp;17.26.&nbsp;Dependency on rule based tasks</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">tasks.addRule(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"Pattern: ping&lt;ID&gt;"</span>) { String taskName -&gt;
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (taskName.startsWith(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"ping"</span>)) {
        task(taskName) &lt;&lt; {
            println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"Pinging: "</span> + (taskName - <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'ping'</span>)
        }
    }
}

task groupPing {
    dependsOn pingServer1, pingServer2
}
</pre><p>Output of <strong class="userinput"><code>gradle -q groupPing</code></strong></p><pre class="screen">&gt; gradle -q groupPing
Pinging: Server1
Pinging: Server2
</pre></div></div><br class="example-break"><p>If you run &ldquo;<code class="literal">gradle -q tasks</code>&rdquo; you won't find a task named
        &ldquo;<code class="literal">pingServer1</code>&rdquo; or &ldquo;<code class="literal">pingServer2</code>&rdquo;, but this script is executing logic
        based on the request to run those tasks.</p><p>如果运行“gradle -q tasks”命令，你可以发现它有“pingServer1”与“pingServer2”任务，但是脚本的执行逻辑是根据请求来执行这些任务的。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="N11431" class="section-anchor" href="#N11431"></a>17.11.&nbsp;Finalizer tasks</h2></div></div></div><div class="note"><p>
                Finalizers tasks are an <em class="firstterm">incubating</em> feature (see <a class="xref" href="feature_lifecycle.html#sec:incubating_state">Section&nbsp;C.1.2, &ldquo;Incubating&rdquo;</a>).
            </p></div><p>Finalizer tasks are automatically added to the task graph when the finalized task is scheduled to run.</p><p>当终结请求任务被调度执行时，终结任务会被自动添加到任务图表上。</p>
			<div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="taskFinalizers"></a><p class="title"><b>Example&nbsp;17.27.&nbsp;Adding a task finalizer</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task taskX &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'taskX'</span>
}
task taskY &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'taskY'</span>
}

taskX.finalizedBy taskY
</pre><p>Output of <strong class="userinput"><code>gradle -q taskX</code></strong></p><pre class="screen">&gt; gradle -q taskX
taskX
taskY</pre></div></div><br class="example-break"><p>Finalizer tasks will be executed even if the finalized task fails.</p><p>即使终结请求任务失败了，终结任务也会继续执行。</p>
<div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="taskFinalizersWithFailure"></a><p class="title"><b>Example&nbsp;17.28.&nbsp;Task finalizer for a failing task</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task taskX &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'taskX'</span>
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">throw</span> <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">new</span> RuntimeException()
}
task taskY &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'taskY'</span>
}

taskX.finalizedBy taskY
</pre><p>Output of <strong class="userinput"><code>gradle -q taskX</code></strong></p><pre class="screen">&gt; gradle -q taskX
taskX
taskY</pre></div></div><br class="example-break"><p>On the other hand, finalizer tasks are not executed if the finalized task didn't do any work, for example if it
        is considered up to date or if a dependent task fails.</p><p>另一方面，如果终结请求任务不执行，那终结任务就不会执行。例如，如果终结请求任务被认为是最新的，或者是它依赖的任务失败了。</p><p style="color:red">上例中，taskX是终结请求任务，taskY是终结任务。</p><p>Finalizer tasks are useful in situations where the build creates a resource that has to be cleaned up regardless
            of the build failing or succeeding. An example of such a resource is a web container that is started before an integration test task
            and which should be always shut down, even if some of the tests fail.</p><p>如果构建过程中生成的资源文件必须被清理，无论构建成功或者失败，终结任务在这种情况下很有用。这种资源的一个示例是web容器，它在集成测试任务执行之前启动，并且在测试任务完成之后应该总是关闭的，哪怕是一些测试失败了。</p><p>To specify a finalizer task you use the <a class="ulink" href="../dsl/org.gradle.api.Task.html#org.gradle.api.Task:finalizedBy(java.lang.Object[])" target="_top"><code class="classname">Task.finalizedBy(java.lang.Object[])</code></a> method.
            This method accepts a task instance, a task name, or any other input accepted by <a class="ulink" href="../dsl/org.gradle.api.Task.html#org.gradle.api.Task:dependsOn(java.lang.Object[])" target="_top"><code class="classname">Task.dependsOn(java.lang.Object[])</code></a>.
        </p><p>可通过 Task.finalizedBy()方法来指定终结任务，这个方法的参数为任务对象、任务名或者Task.dependsOn()方法允许的任何输入。</p>
		</div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:the_idea_behind_gradle_tasks" class="section-anchor" href="#sec:the_idea_behind_gradle_tasks"></a>17.12.&nbsp;Summary</h2></div></div></div><p>If you are coming from Ant, an enhanced Gradle task like <span class="emphasis"><em>Copy</em></span> seems like a cross
            between an Ant target and an Ant task. Although Ant's tasks and targets are really different entities,
            Gradle combines these notions into a single entity. Simple Gradle tasks are like Ant's targets, but enhanced
            Gradle tasks also include aspects of Ant tasks. All of Gradle's tasks share a common API and you can create
            dependencies between them. These tasks are much easier to configure than an Ant task.
            They make full use of the type system, and are more expressive and easier to maintain.
        </p><p>如果你是从Ant转过来的，你会发现一个增强型的Gradle任务如Copy很像是Ant目标与Ant任务的融合体。尽管Ant的任务和目标是不同的实体，Gradle把这两种概念用一个实体来表示。简单的Gradle任务就像Ant的目标，但是增强型的Gradle任务也包括Ant任务方面的东西。所有的Gradle任务都共用通用的API，你可以创建任务间的依赖。这些任务的配置比起Ant任务来说更简单。它们充分利用了系统类型，从而更具表现力，也更容易维护。</p>
		</div><div class="footnotes"><br><hr align="left" width="100"><div class="footnote"><p><sup>[<a href="#N11362" name="ftn.N11362" class="para">7</a>] </sup>You might be wondering why there is neither an import for the
                    <code class="literal">StopExecutionException</code>
                    nor do we access it via its fully qualified name. The reason is, that Gradle adds a set of default imports
                    to your script (see <a class="xref" href="writing_build_scripts.html#script-default-imports">Section&nbsp;16.8, &ldquo;Default imports&rdquo;</a>).
                </p><p>你可能会想到为什么这里既不用导入StopExecutionException，也不用使用完整的限定名来引用。原因就是，Gradle默认为你的脚本添加了一系列的imports语句。</p></div></div></div><div class="navfooter"><div><div class="navbar"><a xmlns:xslthl="http://xslthl.sf.net" href="writing_build_scripts.html" title="Writing Build Scripts - Gradle User Guide Version 2.14.1">Previous</a><span>|</span><a xmlns:xslthl="http://xslthl.sf.net" href="userguide.html" title="Gradle User Guide Version 2.14.1">Contents</a><span>|</span><a xmlns:xslthl="http://xslthl.sf.net" href="working_with_files.html" title="Working With Files - Gradle User Guide Version 2.14.1">Next</a></div></div></div></body></html>