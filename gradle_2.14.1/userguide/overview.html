<html>
    
    <head>
        <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <title>
            Overview - Gradle User Guide Version 2.14.1
        </title>
        <link xmlns:xslthl="http://xslthl.sf.net" type="text/css" rel="stylesheet"
        href="base.css">
        <link xmlns:xslthl="http://xslthl.sf.net" type="text/css" rel="stylesheet"
        href="docs.css">
        <link xmlns:xslthl="http://xslthl.sf.net" type="text/css" rel="stylesheet"
        href="userguide.css">
        <meta content="DocBook XSL Stylesheets V1.75.2" name="generator">
        <link rel="home" href="userguide.html" title="Gradle User Guide Version 2.14.1">
        <link rel="up" href="pt01.html" title="Part&nbsp;I.&nbsp;About Gradle">
        <link rel="prev" href="introduction.html" title="Introduction - Gradle User Guide Version 2.14.1">
        <link rel="next" href="pt02.html" title="Part&nbsp;II.&nbsp;Working with existing builds">
    </head>
    
    <body>
        <div class="navheader">
            <div>
                <div class="navbar">
                    <a xmlns:xslthl="http://xslthl.sf.net" href="introduction.html" title="Introduction - Gradle User Guide Version 2.14.1">
                        Previous
                    </a>
                    <span>
                        |
                    </span>
                    <a xmlns:xslthl="http://xslthl.sf.net" href="userguide.html" title="Gradle User Guide Version 2.14.1">
                        Contents
                    </a>
                    <span>
                        |
                    </span>
                    <a xmlns:xslthl="http://xslthl.sf.net" href="pt02.html" title="Part&nbsp;II.&nbsp;Working with existing builds">
                        Next
                    </a>
                </div>
            </div>
        </div>
        <div class="chapter">
            <div class="titlepage">
                <div>
                    <div>
                        <h1 xmlns:xslthl="http://xslthl.sf.net">
                            <a name="overview">
                            </a>
                            Chapter&nbsp;2.&nbsp;Overview&nbsp;&nbsp;概述
                        </h1>
                    </div>
                </div>
            </div>
            <div class="toc">
                <p>
                    <b>
                        Table of Contents
                    </b>
                </p>
                <dl>
                    <dt>
                        <span class="section">
                            <a href="overview.html#sec:special_feature_of_gradle">
                                2.1. Features
                            </a>
                        </span>
                    </dt>
                    <dt>
                        <span class="section">
                            <a href="overview.html#sec:why_groovy">
                                2.2. Why Groovy?
                            </a>
                        </span>
                    </dt>
                </dl>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h2 class="title">
                                <a xmlns:xslthl="http://xslthl.sf.net" name="sec:special_feature_of_gradle"
                                class="section-anchor" href="#sec:special_feature_of_gradle">
                                </a>
                                2.1.&nbsp;Features&nbsp;&nbsp;特性
                            </h2>
                        </div>
                    </div>
                </div>
                <p>
                    Here is a list of some of Gradle's features.
                </p>
				<p>下面是Gradle的一些特性的列表</p>
                <div class="variablelist">
                    <dl>
                        <dt>
                            <span class="term">
                                Declarative builds and build-by-convention&nbsp;&nbsp;&nbsp;&nbsp;声明式构建和基于约定的构建
                            </span>
                        </dt>
                        <dd>
                            <p>
                                At the heart of Gradle lies a rich extensible Domain Specific Language
                                (DSL) based on Groovy. Gradle pushes declarative builds to the next level
                                by providing declarative language elements that you can assemble as you
                                like. Those elements also provide build-by-convention support for Java,
                                Groovy, OSGi, Web and Scala projects. Even more, this declarative language
                                is extensible. Add your own new language elements or enhance the existing
                                ones, thus providing concise, maintainable and comprehensible builds.
                            </p>
							<p>
								Grale的核心在于基于Groovy语言的丰富可扩展的特定领域语言。Gradle通过提供可随心所欲地组合的声明式语言元素，将声明式构建推进到一个全新的高度。这些元素还为Java、Groovy、
								OSGi、Web和Scala项目提供了基于约定的构建支持。更重要的是，这种声明式语言是可扩展的。
								你可以添加你自己的新语言元素或增加现有的语言元素的功能，从而提供简洁、可维护及易理解的构建。
							</p>
                        </dd>
                        <dt>
                            <span class="term">
                                Language for dependency based programming&nbsp;&nbsp;&nbsp;&nbsp;可编程的依赖语言
                            </span>
                        </dt>
                        <dd>
                            <p>
                                The declarative language lies on top of a general purpose task graph,
                                which you can fully leverage in your builds. It provides utmost flexibility
                                to adapt Gradle to your unique needs.
                            </p>
							<p>通用任务视图之上的声明式语言，你可以在构建中充分运用它。它提供了最大的灵活性，以适应您的独特需求。</p>
                        </dd>
                        <dt>
                            <span class="term">
                                Structure your build&nbsp;&nbsp;&nbsp;&nbsp;构建结构化
                            </span>
                        </dt>
                        <dd>
                            <p>
                                The suppleness and richness of Gradle finally allows you to apply common
                                design principles to your build. For example, it is very easy to compose
                                your build from reusable pieces of build logic. Inline stuff where unnecessary
                                indirections would be inappropriate. Don't be forced to tear apart what
                                belongs together (e.g. in your project hierarchy). Avoid smells like shotgun
                                changes or divergent change that turn your build into a maintenance nightmare.
                                At last you can create a well structured, easily maintained, comprehensible
                                build.
                            </p>
							<p>Gradle丰富灵活的功能，最终可以让你在构建中使用通用的设计原则。例如，它非常容易将可重用的构建逻辑整合到你的构建中。<span style="color:red;">把不必要的不直接关联的东西联接在一起是不可取的，也不要强行将原本一起的东西分割开（比如在你的项目层次中），以免散弹式修改或者发散式变化使得你的构建陷入噩梦般的维护。</span>最终，你可以创建一个结构良好、容易维护、易于理解的构建工程。</p>
							<p style="font-size:12px;">
							<span>散弹式修改（Shotgun Surgery）类似 发散式变化（Divergent Change），但恰恰相反。如果每遇到某种变化，都必须在许多不同的类中做出许多小修改，你所面临的坏味道就是散弹式修改（Shotgun Surgery）。如果需要修改的代码散布在四处，你不但很难找到它们，也很容易忘记某个重要的修改。</span><br/>
							<span>可以使用 Move Method （搬移函数）和 Move Field （搬移字段）把所有需要修改的代码放进同1个类。如果暂时没有合适的类，就创建一个。通常可以运用 Inline Class （将类内联化） 把一系列相关行为放进同一个类。这可能会造成少量的发散式变化（Divergent Change），但可以轻易出来它。</span><br/>
							<span>发散式变化（Divergent Change）是指"一个类受多种变化的影响"，散弹式修改（Shotgun Surgery）则是指"一种变化引起多个类相应修改"。这2种情况都会希望整理代码，使"外界变化"与"需要修改的类"趋于一一对应。</span><br/>
							<span>以上内容都是出自《重构 改善既有代码的设计》</span>
							</p>
                        </dd>
                        <dt>
                            <span class="term">
                                Deep API&nbsp;&nbsp;&nbsp;&nbsp;深层API
                            </span>
                        </dt>
                        <dd>
                            <p>
                                From being a pleasure to be used embedded to its many hooks over the whole
                                lifecycle of build execution, Gradle allows you to monitor and customize
                                its configuration and execution behavior to its very core.
                            </p>
							<p>构建的整个生命周期中内置许多钩子，通过这些生命周期钩子，你可在核心上监听和定制Gradle的依赖形态和运行行为。</p>
                        </dd>
                        <dt>
                            <span class="term">
                                Gradle scales&nbsp;&nbsp;&nbsp;&nbsp;Gradle适应性
                            </span>
                        </dt>
                        <dd>
                            <p>
                                Gradle scales very well. It significantly increases your productivity,
                                from simple single project builds up to huge enterprise multi-project builds.
                                This is true for structuring the build. With the state-of-art incremental
                                build function, this is also true for tackling the performance pain many
                                large enterprise builds suffer from.
                            </p>
							<p>gradle具备高适应性，上至大型企业多项目构建，下到简单的单个项目构建，它大大提高了您的生产力。结构化的构建是很正确的。它艺术般的增量式构建功能，可以挠到大型企业所遭受的性能痛点。</p>
                        </dd>
                        <dt>
                            <span class="term">
                                Multi-project builds&nbsp;&nbsp;&nbsp;&nbsp;多项目构建
                            </span>
                        </dt>
                        <dd>
                            <p>
                                Gradle's support for multi-project build is outstanding. Project dependencies
                                are first class citizens. We allow you to model the project relationships
                                in a multi-project build as they really are for your problem domain. Gradle
                                follows your layout not vice versa.
                            </p>
							<p>Gradle对多项目构建的支持成效显著，项目的依赖是一等公民。它允许你为项目组成结构建立关系模型，因为它实际上针对你的问题所在的。gradle遵循您的布局，反之亦然。</p>
                            <p>
                                Gradle provides partial builds. If you build a single subproject Gradle
                                takes care of building all the subprojects that subproject depends on.
                                You can also choose to rebuild the subprojects that depend on a particular
                                subproject. Together with incremental builds this is a big time saver for
                                larger builds.
                            </p>
							<p>Gradle提供了局部构建，如果你构建一个单独的子项目，它会处理好当前子项目依赖的其他子项目。你也可以选择重新构建被某个子项目所依赖的子项目。对一次庞大的构建来说，增量构建可以节省下大量的时间。</p>
                        </dd>
                        <dt>
                            <span class="term">
                                Many ways to manage your dependencies&nbsp;&nbsp;&nbsp;&nbsp;丰富多样的依赖管理方式
                            </span>
                        </dt>
                        <dd>
                            <p>
                                Different teams prefer different ways to manage their external dependencies.
                                Gradle provides convenient support for any strategy. From transitive dependency
                                management with remote Maven and Ivy repositories to jars or directories
                                on the local file system.
                            </p>
							<p>不同的团队喜欢使用各自的方式来管理外部依赖。从远程Maven和Ivy仓库的传递依赖管理到本地文件系统的jar文件或者目录，Gradle为各种策略提供了便捷的实现方式。</p>
                        </dd>
                        <dt>
                            <span class="term">
                                Gradle is the first build integration tool&nbsp;&nbsp;&nbsp;&nbsp;Gradle是第一等的构建整合工具
                            </span>
                        </dt>
                        <dd>
                            <p>
                                Ant tasks are first class citizens. Even more interesting, Ant projects
                                are first class citizens as well. Gradle provides a deep import for any
                                Ant project, turning Ant targets into native Gradle tasks at runtime. You
                                can depend on them from Gradle, you can enhance them from Gradle, you can
                                even declare dependencies on Gradle tasks in your build.xml. The same integration
                                is provided for properties, paths, etc ...
                            </p>
							<p>Gradle将Ant任务视为一等公民对待，更可喜的是，Ant项目也同样被视为一等公民。Gradle为Ant项目提供了深层转换，在运行时可将Ant的目标转换成本地的Gradle任务。你可以把它们放心交给Gradle，你也可以使用Gradle来强化它们，你甚至可以在build.xml中定义一个Gradle任务来声明依赖。属性、路径等为此提供了一致的功能集成。</p>
                            <p>
                                Gradle fully supports your existing Maven or Ivy repository infrastructure
                                for publishing and retrieving dependencies. Gradle also provides a converter
                                for turning a Maven
                                <code class="filename">
                                    pom.xml
                                </code>
                                into a Gradle script. Runtime imports of Maven projects will come soon.
                            </p>
							<p>Gradle完全支持从现有的Maven或者Ivy仓库设施发布或检索依赖项，它也包含了转换器，可将Maven的pom.xml文件转换成Gradle脚本。运行时导入Maven的功能很快会到来。</p>
                        </dd>
                        <dt>
                            <span class="term">
                                Ease of migration&nbsp;&nbsp;&nbsp;&nbsp;迁移是一种享受
                            </span>
                        </dt>
                        <dd>
                            <p>
                                Gradle can adapt to any structure you have. Therefore you can always develop
                                your Gradle build in the same branch where your production build lives
                                and both can evolve in parallel. We usually recommend to write tests that
                                make sure that the produced artifacts are similar. That way migration is
                                as less disruptive and as reliable as possible. This is following the best-practices
                                for refactoring by applying baby steps.
                            </p>
							<p>Gradle可以适应你当前使用的任何结构的项目，因此，你可以在你分发产品的同一个分支上添加Gradle构建的支持，它们可并行发展。我们常常推荐人们写测试用例来确保产出的工件具备同样的特性。<span style="color:red">这种迁移破坏性低可靠性高，按照它简单易懂的步骤，这是重构的最佳实践。</span></p>
                        </dd>
                        <dt>
                            <span class="term">
                                Groovy&nbsp;&nbsp;&nbsp;&nbsp;Groovy语言
                            </span>
                        </dt>
                        <dd>
                            <p>
                                Gradle's build scripts are written in Groovy, not XML. But unlike other
                                approaches this is not for simply exposing the raw scripting power of a
                                dynamic language. That would just lead to a very difficult to maintain
                                build. The whole design of Gradle is oriented towards being used as a language,
                                not as a rigid framework. And Groovy is our glue that allows you to tell
                                your individual story with the abstractions Gradle (or you) provide. Gradle
                                provides some standard stories but they are not privileged in any form.
                                This is for us a major distinguishing feature compared to other declarative
                                build systems. Our Groovy support is not just sugar coating. The whole
                                Gradle API is fully Groovy-ized. Adding Groovy results in an enjoyable
                                and productive experience.
                            </p>
							<p>Gradle的构建脚本是用Groovy语言写的，而不是XML。但是与其他用法不同的是，这不仅仅是展现出动态语言的原始脚本威力。那只会导致使构建变得非常难以维护。总的设计原则是让它像一门言语一样，而不是像一个僵化的框架。Gradle充其量只是胶水之类的粘合剂，它把你的故事同Gradle（或者你）赋予的抽象粘合在一起。Gradle有标准套路的故事，但并不是在所有地方都能适用。这是它与其他声明式构建系统最主要的不同。我们的Groovy支持可不只是一层糖衣，所有的Gradle API是完全Groovy化的。添加Groovy会带来愉快富有成效的体验。</p>
                        </dd>
                        <dt>
                            <span class="term">
                                The Gradle wrapper&nbsp;&nbsp;&nbsp;&nbsp;Gradle包装器
                            </span>
                        </dt>
                        <dd>
                            <p>
                                The Gradle Wrapper allows you to execute Gradle builds on machines where
                                Gradle is not installed. This is useful for example for some continuous
                                integration servers. It is also useful for an open source project to keep
                                the barrier low for building it. The wrapper is also very interesting for
                                the enterprise. It is a zero administration approach for the client machines.
                                It also enforces the usage of a particular Gradle version thus minimizing
                                support issues.
                            </p>
							<p>Gradle包装器让你可以在任何安装了Gradle的机器上执行Gradle构建，这对于一些持续集成服务器来说是很有用的，对于开源项目来说也是很有用，它可以降低构建障碍。包装器对于企业来说也是让人激动的。对于客户端机器来说它是零管理成本的方法。它还强制使用特定版本的Gradle，从而最大限度地减少了支持问题。</p>
                        </dd>
                        <dt>
                            <span class="term">
                                Free and open source&nbsp;&nbsp;&nbsp;&nbsp;免费，开源
                            </span>
                        </dt>
                        <dd>
                            <p>
                                Gradle is an open source project, and is licensed under the
                                <a class="ulink" href="http://www.gradle.org/license" target="_top">
                                    ASL
                                </a>
                                .
                            </p>
							<p>Gradle是一个开源项目，遵循ASL协议。</p>
                        </dd>
                    </dl>
                </div>
            </div>
            <div class="section">
                <div class="titlepage">
                    <div>
                        <div>
                            <h2 class="title">
                                <a xmlns:xslthl="http://xslthl.sf.net" name="sec:why_groovy" class="section-anchor"
                                href="#sec:why_groovy">
                                </a>
                                2.2.&nbsp;Why Groovy?
                            </h2>
                        </div>
                    </div>
                </div>
                <p>
                    We think the advantages of an internal DSL (based on a dynamic language)
                    over XML are tremendous when used in
                    <span class="emphasis">
                        <em>
                            build scripts
                        </em>
                    </span>
                    . There are a couple of dynamic languages out there. Why Groovy? The answer
                    lies in the context Gradle is operating in. Although Gradle is a general
                    purpose build tool at its core, its main focus are Java projects. In such
                    projects the team members will be very familiar with Java. We think a build
                    should be as transparent as possible to
                    <span class="emphasis">
                        <em>
                            all
                        </em>
                    </span>
                    team members.
                </p>
				<p>我们认为，在构建脚本中使用内部的特定领域语言（基于一种动态语言）相对于使用XML的优势是巨大的（Maven与Ant使用XML作为构建脚本）。但是动态语言有好几种，为什么要用Groovy？答案就在于Gradle所操作的上下文。尽管从本质上来讲，Gradle只是一种通用的聚焦于Java项目的构建工具。而在Java项目中，项目成员对Java都比较熟悉。我们认为一个构建工程对于所有项目成员来说都应该是尽可能透明的。</p>
                <p>
                    In that case, you might argue why we don't just use Java as the language
                    for build scripts. We think this is a valid question. It would have the
                    highest transparency for your team and the lowest learning curve, but because
                    of the limitations of Java, such a build language would not be as nice,
                    expressive and powerful as it could be.
                    <sup>
                        [
                        <a href="#ftn.N100C4" name="N100C4" class="footnote">
                            1
                        </a>
                        ]
                    </sup>
                    Languages like Python, Groovy or Ruby do a much better job here. We have
                    chosen Groovy as it offers by far the greatest transparency for Java people.
                    Its base syntax is the same as Java's as well as its type system, its package
                    structure and other things. Groovy provides much more on top of that, but
                    with the common foundation of Java.
                </p>
				<p>在这种情况下，你可能会对此心存疑惑：为什么我们不干脆用Java语言来编写构建脚本。这个问题问得好。首先，一个构建工具对于开发团队来说，应该是透明度最高且学习曲线是最低的，但是由于Java本身的限制，这样一种构建语言不会那么灵活好用并且又功能强大。Python、Groovy、Ruby这些语言会比它做得更好。我们选择Groovy，它对Java开发者来说具有最高的透明度，它的基本语法跟Java非常相似，还有类型体系、包组织结构及其他的特性也类似。Groovy拥有Java的通用功能，但能做的事却远超Java。</p>
                <p>
                    For Java developers with Python or Ruby knowledge or the desire to learn
                    them, the above arguments don't apply. The Gradle design is well-suited
                    for creating another build script engine in JRuby or Jython. It just doesn't
                    have the highest priority for us at the moment. We happily support any
                    community effort to create additional build script engines.
                </p>
				<p>当然啦，具有Python或者Ruby基础知识的或者是想学习Python或者Ruby知识的Java开发者例外。Gradle设计得很适合创建使用JRuby或者Jython语言的构建脚本引擎。对于我们来说，这不是现在最紧急的事。我们很乐意支持任何社区致力于创建其他语言的构建脚本引擎。</p>
            </div>
            <div class="footnotes">
                <br>
                <hr align="left" width="100">
                <div class="footnote">
                    <p>
                        <sup>
                            [
                            <a href="#N100C4" name="ftn.N100C4" class="para">
                                1
                            </a>
                            ]
                        </sup>
                        At
                        <a class="ulink" href="http://www.defmacro.org/ramblings/lisp.html" target="_top">
                            http://www.defmacro.org/ramblings/lisp.html
                        </a>
                        you find an interesting article comparing Ant, XML, Java and Lisp. It's
                        funny that the 'if Java had that syntax' syntax in this article is actually
                        the Groovy syntax.
                    </p>
					<p>在……你可以找到一个有趣的文章，关于Ant、XML、Java和Lisp对比的。在这个专题中，“如果Java有这种语法”的语法事实上正是Groovy的语法，很搞笑。</p>
                </div>
            </div>
        </div>
        <div class="navfooter">
            <div>
                <div class="navbar">
                    <a xmlns:xslthl="http://xslthl.sf.net" href="introduction.html" title="Introduction - Gradle User Guide Version 2.14.1">
                        Previous
                    </a>
                    <span>
                        |
                    </span>
                    <a xmlns:xslthl="http://xslthl.sf.net" href="userguide.html" title="Gradle User Guide Version 2.14.1">
                        Contents
                    </a>
                    <span>
                        |
                    </span>
                    <a xmlns:xslthl="http://xslthl.sf.net" href="pt02.html" title="Part&nbsp;II.&nbsp;Working with existing builds">
                        Next
                    </a>
                </div>
            </div>
        </div>
    </body>

</html>
